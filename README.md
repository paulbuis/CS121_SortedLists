# Sorted Lists

So far, the best searching technique we know
is the *binary search* algorithm. We
can keep an ArrayList<T> in sorted order
by first doing a binary search to what index
an item belongs at and then using the
`add(int index, T item)` method to put it there.

See [java/cs121/SortedList](src/main/java/cs121/SortedList.java)

Note that in order to specify a specific ordering, we
need to provide the binary search with a
[`java.util.Comparator<T>`](https://www.geeksforgeeks.org/comparator-interface-java/)
which has a single method `int compare(T t1, T t2)`.

The result of the `compare(a,b)` method is:

* 0 if `a` and `b` are indistinguishable under the given ordering rules
* &lt; 0 if `a<b` under the ordering rules
* &gt; 0 if `a>b` under the ordering rules

For numerical values, this can be easily accomplished
by having `compare(a,b)` return `a-b`.

Some classes, such as the numerical wrapper classes
and `String` implement the `Comparable<T>` interface
which provides a `int compareTo(T)` method which leads to a
*natural ordering* defined by:
```java
class NaturalOrder<T extends Comparable<T>> implements Comparator<T> {
    public int compare(T a, T b) {
        return a.compareTo(b);
    }
}
```

Consider the following as a list of strings:
```
Alice
apple
zebra
Zoology 
```

This is a "case-insensitive" ordering, not the
natural ordering which would be:

```
Alice
Zoology
apple
zebra
```

In Java, a `Comparator` generating the natural ordering for any `Comparable` is available via
the static method `java.util.Comparator.naturalOrder()`.
The case-insensitive order can be generated by
the `String.CASE_INSENSITIVE_ORDER` static data member.

Neither of these is *dictionary* order
which is illustrated by our very
non-authoritative and incomplete
[dictionary file](dict200k.txt). Note that
this is *almost* the same as the case-insensitive
order, but the capitalized forms of
words come before the same word in
uncapitalized form. See the
[DictionaryOrder](src/main/java/app/DictionaryOrder.java) class for a `Comparator`
that generates this ordering.

## Sorted Lists as Sets

For today's lab, we will use
the
[`SimpleSet`](src/main/java/cs121/SimpleSet.java)
interface to describe a simple set of
operations on a set.

Then, we implement this interface
with the [`SortedSet`](src/main/java/cs121/SortedSet.java) class.
Note that this overrides only one method
of the `SortedList` class:
```java
    @Override
    public boolean add(T item) {
        if (!contains(item)) {
            super.add(item);
            return true;
        }
        return false;
    }
```

Since I want to work with sets whose
elements are of type `String`, I've
created a specialization of the `SimpleSet`
interface in the
[`Dict`](src/main/java/cs121/Dict.java) interface.

Then, I've written the `Dict` interface
with a couple of different classes. First, the
[`DictionaryListSet`](src/main/java/app/DictionaryListSet.java) class extends `SortedList<String>`
and implements `Dict`.

For comparison with the standard `java.util` classes
I've written
[`DictionaryTreeSet`](src/main/java/app/DictionaryTreeSet.java)
which extends `java.util.TreeSet<String>` and
[`DictionaryTreeSet`](src/main/java/app/DictionaryHashSet.java)
which extends `java.util.TreeSet<String>`.

## Lab Experiment

### Record Timing #1

Run the `main()` method in
[`DictionaryLookup`](src/main/java/app/DictionaryLookup.java)

Record timings in a table like the one shown below.

The numbers for the first two columns should appear immediately.
For the third column, search for "america" twice and record the second
time.

 | Data Structure     | I/O Time  | Construction Time | Search Time |
 | :---               |      :--- | :--- | :--- | 
 | DictionaryListSet  | | | |
 | DictionaryTreeSet  | | | |
 | DictionaryHashSet  | | | |

### Record Timing #2

Change `DictionaryLookup.java` so
instead of a `DictionaryListSet` it uses
a `DictionaryTreeSet` and record the second
in your table.

### Record Timing #3

Change `DictionaryLookup.java` so
instead of a `DictionaryTreeSet` it uses
a `DictionaryHashSet` and record the second
in your table.

## Reflection

I'm guessing all three of the lines have
similar magnitude numbers (give or take maybe a factor of 5).

The theoretical performance of these three data structures
is very different:

* A `DictionaryListSet` should search in O(log N) time
and require O(N<sup>2</sup>) to construct (worst case).

* A `DictionaryTreeSet` should search in O(log N) time
  and require O(NlogN) to construct (worst case).

* A `DictonaryHashSet` as constant average time and an average time to search proportional
 to N to construct.

I've avoided the worst case for `DictionaryListSet` to
construct by using an ordering that matches the ordering in
the dictionary file we are using. Changing the ordering should
have little effect on the TreeSet.

Be prepared to answer the following 3
questions with the instructor:

1. So, imagine we had a much smaller set to search,
would this tend to favor a `HashSet` or a `TreeSet` ?

2. Similarly, imagine we had a much smaller set to search,
would this tend to favor a `HashSet` or a `TreeSet` ?

3. Finally, suppose we had objects of a type other than
`String` to sort that had no easy
way to compare (for example: latitude, longitude pairs),
would this tend to favor choosing to use a `HashSet` or a `TreeSet` ?

## Fun Experiment

After Lab, change `DictionaryLookup.java` back to using
a `DictionaryListSet`. Then, change `DictionaryListSet`
to initialize its superclass using `Comparator.naturalOrder()`
instead of `new DictionaryOrder()`. Run `main()`
in `DictionaryLookup.java` again. If it seems to take
a long time, that is what I am expecting when
the ordering does not follow what the data file uses
and many of the insertions into the underlying `ArrayList<String>`
are taking time proportional to N instead of constant time.